<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Login</title>

  <!-- Netlify Identity -->
  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>

  <!-- Site assets -->
  <link rel="stylesheet" href="assets/style.css" />

  <!-- Identity init + core (order matters) -->
  <script src="assets/identity.js"></script>
  <script src="assets/app-core.js"></script>
  <!-- Login is public; guard is not required, but harmless. Keep if you want. -->
  <script src="assets/acl-guard.js"></script>
</head>

<body>
  <div class="container">
    <h2>Login</h2>

    <input id="loginEmail" type="email" placeholder="Email" autocomplete="email" />
    <input id="loginPass" type="password" placeholder="Password" autocomplete="current-password" />

    <button id="btnLogin" type="button">Enter</button>
    <button id="btnLogout" type="button">Logout</button>

    <div id="loginMsg" class="tiny muted" style="margin-top:10px;"></div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const loginEmail = document.getElementById("loginEmail");
  const loginPass  = document.getElementById("loginPass");
  const btnLogin   = document.getElementById("btnLogin");
  const btnLogout  = document.getElementById("btnLogout");
  const loginMsg   = document.getElementById("loginMsg");

  function setMsg(msg, type="") {
    if(!loginMsg) return;
    loginMsg.textContent = msg || "";
    loginMsg.className = type ? ("msg " + type) : "tiny muted";
  }

  function disableLogin(disabled){
    if(btnLogin) btnLogin.disabled = !!disabled;
    if(btnLogin) btnLogin.style.opacity = disabled ? "0.7" : "1";
  }

  async function doLogin(email, password){
    if (!window.netlifyIdentity) throw new Error("Netlify Identity is not available.");

    // Ensure identity is initialised (identity.js usually does this)
    try { window.netlifyIdentity.init && window.netlifyIdentity.init(); } catch {}

    // Use GoTrue client directly for custom forms
    const gt = window.netlifyIdentity.gotrue;
    if (!gt || typeof gt.login !== "function") {
      throw new Error("Netlify Identity GoTrue client is not ready (missing gotrue.login).");
    }

    // gotrue.login(email, password, remember)
    await gt.login(email, password, true);

    const user = window.netlifyIdentity.currentUser && window.netlifyIdentity.currentUser();
    if (!user || !user.email) throw new Error("Login failed (no currentUser).");
    return user;
  }

  async function syncAndValidate(email){
    // Save session locally (used by app-core/guards)
    if (typeof anwSave === "function") {
      anwSave((window.ANW_KEYS && ANW_KEYS.SESSION) ? ANW_KEYS.SESSION : "anw_session", { email });
    } else {
      localStorage.setItem("anw_session", JSON.stringify({ email }));
    }

    // Sync store (ACL + USERS). USERS may be forbidden for non-admins; owner will pass.
    if (typeof anwInitStore === "function") {
      await anwInitStore();
    } else if (typeof window.anwSyncFromServer === "function") {
      await window.anwSyncFromServer();
    }

    // If we CAN see anw_users, validate registration exists
    const keyUsers = (window.ANW_KEYS && ANW_KEYS.USERS) ? ANW_KEYS.USERS : "anw_users";
    const users = (typeof anwLoad === "function") ? anwLoad(keyUsers, []) : [];
    const me = Array.isArray(users) ? users.find(u => (u && u.email || "").toLowerCase().trim() === email.toLowerCase().trim()) : null;

    // If users store is unavailable (403), users may be empty — don't hard-block here.
    // But if we DO have users and the user is missing, show a clear message.
    if (Array.isArray(users) && users.length && !me) {
      throw new Error("Login OK, but no registration found in anw_users for this email.");
    }

    return me;
  }

  // ============ Handlers ============
  if (btnLogin) {
    btnLogin.addEventListener("click", async () => {
      const email = (loginEmail?.value || "").trim();
      const pass  = (loginPass?.value || "").trim();

      if (!email || !pass) {
        setMsg("Please enter email and password.", "error");
        return;
      }

      disableLogin(true);
      setMsg("Signing in…");

      try {
        await doLogin(email, pass);
        await syncAndValidate(email);

        setMsg("Login successful. Redirecting…", "success");
        window.location.href = "dashboard.html";
      } catch (err) {
        console.error(err);
        setMsg(err && err.message ? err.message : "Login error.", "error");
      } finally {
        disableLogin(false);
      }
    });
  }

  // Enter key submits
  [loginEmail, loginPass].forEach(el => {
    if(!el) return;
    el.addEventListener("keydown", (e) => {
      if(e.key === "Enter"){
        e.preventDefault();
        btnLogin && btnLogin.click();
      }
    });
  });

  if (btnLogout) {
    btnLogout.addEventListener("click", async () => {
      try { window.netlifyIdentity && window.netlifyIdentity.logout && window.netlifyIdentity.logout(); } catch {}
      try { localStorage.removeItem((window.ANW_KEYS && ANW_KEYS.SESSION) ? ANW_KEYS.SESSION : "anw_session"); } catch {}
      if(loginPass) loginPass.value = "";
      setMsg("You have been logged out.", "info");
    });
  }
});
</script>

</body>
</html>
